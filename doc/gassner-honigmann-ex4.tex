\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{textcomp}
\usepackage[top=0.8in, bottom=0.8in, left=0.8in, right=0.8in]{geometry}
\usepackage{multirow}
\usepackage{paralist}
\usepackage[table,xcdraw]{xcolor}
\usepackage{courier}
\usepackage{graphicx}
\usepackage{array}
\usepackage{wrapfig}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{titling}
\usepackage{blindtext}

% Put your group number and names in the author field %
\title{\bf Excercise 4\\ Implementing a centralized agent}
\author{Group \textnumero76: Simon Honigmann, Arthur Gassner}

% N.B.: The report should not be longer than 3 pages %

\begin{document}
\maketitle
\section{Solution Representation}
\subsection{Variables}
% Describe the variables used in your solution representation %
A \texttt{Solution} class was created to better store and manage information for each potential delivery solution. A \texttt{Solution} object consists of a \texttt{HashMap} of \texttt{Vehicle}s as key and \texttt{ArrayList}s of \texttt{Action}s as value, also called an agenda. A reduced version of each agenda, which simply includes information for whether the task is to be picked up or delivered and where, in the order in which the vehicle is supposed to perform those actions is also stored in the \texttt{Solution}. Finally, the texttt{Solution} has a method, which can convert the simplified list of pick-ups and drop-offs into a complete action list suitable for Plan generation.

\subsection{Constraints}
% Describe the constraints in your solution representation %
Relatively few constraints are applied to the solution representation. Constraints include the following:

\begin{compactenum}
	\item Solutions cannot result in a vehicle carrying more tasks that its capacity allows.
	\item Deliveries must always be after pick-ups in the generated task lists.
	\item A vehicle which picks up a task must also deliver that task. There is no exchange between vehicles, within a plan.
	\item All tasks provided upon initialization must be picked up and delivered in the generated solution.
	\item A solution must be generated within the time-out specified in the default\_settings.xml file. 
\end{compactenum}

\subsection{Objective function}
% Describe the function that you optimize %
The function to be optimized is the sum of the costs incurred by each vehicle for a given solution. This allows each solution's optimality to be comparable.

\section{Stochastic optimization}

\subsection{Initial solution}
% Describe how you generate the initial solution %
Several methods for generating an initial solution were explored. First, a naive approach which sequentially distributed tasks between each vehicle, to result in a distributed initial task allocation. Second was a greedy approach, which assigned every single task to the first vehicle in the vehicle list which could carry the task. This resulted in the first vehicle having the majority of tasks assigned to it. It is assumed for all initial solutions, that at least one vehicle can carry the largest task in the specified task list. If a task is ever larger than the selected vehicle's capacity, it is assigned to a different vehicle until the selected vehicle has a large enough capacity.\\

Ultimately, our testing showed that the naive approach was the most consistent with a low total final cost. This initialization was therefore used in all future experiments. 

\subsection{Generating neighbours}
% Describe how you generate neighbors %
First a vehicle that has at least 1 task is randomly selected. Then each task carried by the chosen vehicle is reinserted into for each possible location of the task pick-up and task delivery in every vehicle (including the chosen vehicle). Each solution represented by the new task location is set as a new neighbour. Every generation created by this method therefore contains neighbours created by swapping task positions within a given vehicle and by transferring tasks between vehicles. Only neighbours that satisfy the constraints listed above are returned. The neigbours generation therefore works in $O(number\_of\_vehicles * (number\_of\_tasks)^3)$.

\subsection{Stochastic optimization algorithm}
% Describe your stochastic optimization algorithm %

Every time neighbours are generated, the local minimum is first found and compared to the current best solution. If it outperforms the current best, the current best is replaced by the local minimum. To implement the stochastic local portion of stochastic local search, two probability thresholds are defined: \texttt{P\_Upper} and \texttt{P\_Lower} which determine how the next iteration's base solution will be selected. Every iteration, a random number is generated between 0 and 1. If the number is below \texttt{P\_Lower}, the local minimum solution is returned and used to generate the next set of neighbours. If the number is between \texttt{P\_Upper} and \texttt{P\_Lower}, inclusive, the previous solution is used to generate neighbours. If the number is above \texttt{P\_Upper}, a random solution is selected from the set of neighbours and is used to generate future neighbours.

To formalize our approach, we added local-minimum loop detection. If the optimal solution stayed the same for more than \texttt{MAX\_REPEAT} times, then a random neighbour is automatically selected. This is to try to avoid getting caught at local-minima, without sacrificing performance early in the search by selecting random neighbours when the new local minima are consistently improving. After adding this, \texttt{P\_Upper} was set to 1 so that random selection is only used when solution stagnation occurs.

\section{Results}
For all experiments, plan time out was set to 30 s and every value reported was averaged over 3 trials. 
\subsection{Experiment 1: Model parameters}
% if your model has parameters, perform an experiment and analyze the results for different parameter values %
In the first experiment we tested the impact of texttt{P\_Lower} and \texttt{MAX\_REPEAT} on the final plan cost.
\subsubsection{Setting}
% Describe the settings of your experiment: topology, task configuration, number of tasks, number of vehicles, etc. %
% and the parameters you are analyzing %
Settings for this experiment are specified in \texttt{E1\_centralized.xml} and \texttt{E1\_settings\_default.xml}. This experiment always used 30 tasks, 4 vehicles, and the England topology. Values of \texttt{MAX\_REPEAT} of 2, 10 and 20, and  \texttt{P\_Lower} of 0.1, 0.5, 0.8 and 1 were tested. The results are included in the following section. 
\subsubsection{Observations}
% Describe the experimental results and the conclusions you inferred from these results 


\begin{table}
	\centering
	\caption{Plan Cost for Different \texttt{MAX\_REPEAT} and \texttt{P\_Lower} Values}
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		\multirow{2}{*}{MAX\_REPEAT} & \multicolumn{4}{c|}{P\_Lower} \\ \cline{2-5} 
		& 0.1 & 0.5 & 0.8 & 1.0 \\ \hline
		2 & \$42,815 & \$26,079 & \$19,338 & \$19,806 \\ \hline
		10 & \$24,552 & \$17,556 & \$16,087 & \$15,268 \\ \hline
		20 & \$21,051 & \$17,251 & \$15,724 & \$18,158 \\ \hline
	\end{tabular}
\end{table}


As is shown in the table, \texttt{MAX\_REPEAT} and \texttt{P\_Lower} strongly influence the performance of the solution generation. When \texttt{P\_Lower} is too small, the search is too likely to hold on to old solutions and does not explore enough to find optimal solutions. As \texttt{P\_Lower} increases, the solution favours local minima and stops holding onto old solutions. There also appears to be an optimal number of allowed repetitions during loop checking. Too few and the search wanders in random directions too often. Too many, and the algorithm gets stuck at local minima without exploring enough to find more optimal solutions.

\subsection{Experiment 2: Different configurations}
% Run simulations for different configurations of the environment (i.e. different tasks and number of vehicles) %
In this experiment, we wanted to compare the efficiencies of different numbers of vehicles to see how evenly distributed tasks were among the vehicles. 
\subsubsection{Setting}
% Describe the settings of your experiment: topology, task configuration, number of tasks, number of vehicles, etc. %
Settings for this experiment are specified in \texttt{E2\_centralized.xml} and \texttt{E1\_settings\_default.xml}. We run the experiment for 1, 4 and 10 vehicles, each time with 5 and 30 tasks.\\


\subsubsection{Observations}
% Describe the experimental results and the conclusions you inferred from these results %
% Reflect on the fairness of the optimal plans. Observe that optimality requires some vehicles to do more work than others. %
% How does the complexity of your algorithm depend on the number of vehicles and various sizes of the task set? %
Table 2 shows the cost for different plans, as well as the number of vehicles actually carrying tasks (VCT) for each plan. As can be seen from the data in Table 2, for a small number of tasks, there is little benefit of having multiple vehicles. There is also a high disparity among vehicles in terms of number of tasks carried. One vehicle tends to carry all or the majority of the tasks for the group. As the number of tasks increases, the task distribution also improves, and more vehicles have tasks to carry. However, it is still almost always found to be more efficient for most vehicles, as seen with the 10 vehicle data points, to sit idle. We would expect a very different distribution of labour if the optimization function included a time cost, preferring faster solutions to slower solutions. This would result in a more realistic allocation of resources, each vehicle carrying tasks in order to distribute everything as quickly as possible.

\begin{table}[h]	
	\centering
	\caption{Plan Cost and Number of Vehicles Carrying Tasks for Different Numbers of Vehicles and Tasks}
	\begin{tabular}{c|c|c|c|c|}
		\cline{2-5}
		\multirow{2}{*}{} & \multicolumn{4}{c|}{Number of Vehicles} \\ \cline{2-5} 
		& \multicolumn{2}{c|}{4} & \multicolumn{2}{c|}{10} \\ \hline
		\multicolumn{1}{|c|}{\# of Tasks} & Cost & VCT & Cost & VCT \\ \hline
		\multicolumn{1}{|c|}{5} & \$5,752 & 1 & \$5,752 & 1 \\ \hline
		\multicolumn{1}{|c|}{30} & \$16,966 & 2.33 & \$16,625 & 3 \\ \hline
	\end{tabular}
\end{table}

The complexity of the algorithm grows quickly with the number of tasks, as it generates neighbours for every possible pick-up and drop-off action positions in the recipient vehicle's task list. This results in considerable growth in complexity with respect to the number of tasks. The growth is proportional to the number of vehicles. If a very large number of tasks were to be computed, the algorithm could be modified to only generate a limited number of random neighbours rather than all possible neighbours. 
\end{document}